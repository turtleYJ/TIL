# 영속성 컨텍스트
- "엔티티를 영구 저장하는 환경"
- EntitiyManager.persist(entity);
- 이 코드가 단순히 DB에 엔티티를 만드는 것보다 더 깊은 내용을 함축한다.(엔티티를 영속성 컨텍스트에 저장한다.)
- 영속성 컨텍스트는 논리적 개념이다.(눈에 보이지 않음)
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

![](Images/1.png)

## 엔티티의 생명주기
1. 비영속(new/transient)
- 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

```java
Member meber = new Member();
member.setId("member1");
member.setUsername("회원1");
```

2. 영속(managed)
- 영속성 컨텍스트에 관리되는 상태

3. 준영속(detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태

4. 삭제(removed)
- 삭제된 상태

## 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- em.flush()를 하게되면 변경 '쓰기 지연 SQL저장소'에 있던 SQL문들이 커밋된다.
- 이때 1차 캐시들을 그대로 유지된다.

### 영속성 컨텍스트를 플러시하는 방법
- em.flush() - 직접호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

### 플러시 정리
- 영속성 컨텍스트를 비우지 않는다.
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화시킨다.
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨
- 단, JPQL 쿼리 실행은 예외적으로 플러시를 자동으로 호출하고 코드가 실행된다.

## 영속 -> 준영속
- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된(detached) 것을 준영속 상태라 한다.
- 준영속 상태에서는 영속성 컨텍스트가 제공하는 기능(dirty checking 등..)을 사용할 수 없다.

### 준영속 상태로 만드는 방법
- em.detach(entity) : 특정 엔티티만을 준영속 상태로 전환.
- em.clear() : 영속성 컨텍스트를 완전히 초기화.
- em.close() : 영속성 컨텍스트를 종료.

## 영속성 컨텍스트의 이점
- 1차 캐시 -같은 엔티티에 대해 find를 여러번 해도 쿼리문을 여러번 실행하지 않는다.
- 동일성 보장 - 1차 캐시에서 가져다 씀으로 참조 변수와 같이 동일성이 보장된다.(==)
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지(Dirty Checking) : 추가로 save해주지 않아도 인스턴스에 대한 참조 변수처럼 자연스럽게 데이터에 대한 update가 진행된다.
- 지연 로딩(Lazy Loading)

# 엔티티 매핑

![](Images/매핑%20어노테이션.png)

## 객체와 테이블 매핑
- Entity가 붙은 클래스는 JPA가 관리
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) 

## 데이터베이스 스키마 자동 생성
- 스키마란? 스키마는 데이터베이스 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
- hibernate.hbm2ddl.auto의 속성값을 통해 할 수 있다.
- create : 기존 테이블 삭제 후 다시 생성
- create-drop : create와 같으나 종료시점에 테이블 DROP
- update : 변경분만 반영(운영DB에서는 사용하면 안됨)
- validate : 엔티티와 테이블이 정상 매핑되었는지 확인
- none : 사용하지 않음
- 운영 장비에는 절대 create, create-drop, update 사용하면
안된다.


## 필드와 컬럼 매핑
![](Images/@Column.png)

### @Enumerated (오라클에서 체크 제약조건으로 사용자와 관리자를 구분했던 것의 기능을 한다.)
- 자바 enum 타입을 매핑할 때 사용
- ORDINAL사용 금지. (순번으로 나온다.)
- STRING으로 사용하여 이름을 데이터 베이스에 저장한다.

### @Temporal
- 날짜 타입을 매핑할 때 사용.
- LocalDate, LocalDateTime을 사용할 떄는 생략 가능(최신 하이버네이트 지원)
- TmeporalType.DATE : 날짜, 데이터베이스 date 타입과 매핑
- TemporalType.Time : 시간, 데이터베이스 time 타입과 매핑
- TemporalType.TIMESTAMP : 날짜와 시간, 데이터베이스 timestamp 타입과 매핑

### @Lob
- 데이터베이스 BLOB, CLOB 타입과 매핑
- @Lob에는 지정할 수 있는 속성이 없다.
- 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑

@Transient
- 필드 매핑X
- 데이터베이스에 저장X, 조회X
- 주로 메모리상에서 임시로 어떤 값을 보관하고 싶을 때 사용

## 기본 키 매핑
- 직접 할당 : @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY : 데이터베이스에 위임, MYSQL
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE
    - @SequenceGenerator 필요
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator필요
  - AUTO : 방언에 따라 자동 지정, 기본값

- @Id
- @GeneratedValue

# 연관관계 매핑 기초
## 단방향 연관관계
- 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다.
- 객체의 참조와 테이블의 외래 키를 매핑하는 것이 목표다.

### 방향(Direction) : [단방향, 양방향]
- 단방향 : 둘 중 한 쪽만 참조하는 것
- 양방향 : 양쪽이 모두 참조하는 것

### 다중성(Multiplicity) : [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)]

### 연관관계의 주인(owner) : 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다. 

## 양방향 연관관계 매핑 하는 법
- 다대일 중 다에 해당하는(ex Member)부분에 테이블상의 FK에 해당하는 필드에 @ManyToOne이노테이션을 달아준다.
- @JoinColumn이노테이션을 달아주고 name 속성으로 컬럼명을 명시해 준다.
- 이와 연관관계를 가지는 그 반대편 엔티티(ex Team)의 필드에 @OneToMany어노테이션과 @mappedBy속성으로 주인 엔티티의 필드값을 입력해 준다.
- 여기서 주인은 Member엔티티의 team 필드가 된다.
- 연관관계의 주인은 외래 키가 있는 곳이 된다.
- 테이블상의 외래키 데이터에 접근할 수 있는 것은 연관관계의 주인뿐이다.
- 주인이 아닌 쪽은 읽기만 할 수 있다.
- 이러한 복잡성은 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하기 때문이다.
- 반면에 엔티티는 참조를 사용하므로 양방향의 참조가 필요하다.