# 영속성 컨텍스트
- "엔티티를 영구 저장하는 환경"
- EntitiyManager.persist(entity);
- 이 코드가 단순히 DB에 엔티티를 만드는 것보다 더 깊은 내용을 함축한다.(엔티티를 영속성 컨텍스트에 저장한다.)
- 영속성 컨텍스트는 논리적 개념이다.(눈에 보이지 않음)
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다.

![](Images/1.png)

## 엔티티의 생명주기
1. 비영속(new/transient)
- 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

```java
Member meber = new Member();
member.setId("member1");
member.setUsername("회원1");
```

2. 영속(managed)
- 영속성 컨텍스트에 관리되는 상태

3. 준영속(detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태

4. 삭제(removed)
- 삭제된 상태

## 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- em.flush()를 하게되면 변경 '쓰기 지연 SQL저장소'에 있던 SQL문들이 커밋된다.
- 이때 1차 캐시들을 그대로 유지된다.

### 영속성 컨텍스트를 플러시하는 방법
- em.flush() - 직접호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

### 플러시 정리
- 영속성 컨텍스트를 비우지 않는다.
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화시킨다.
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨
- 단, JPQL 쿼리 실행은 예외적으로 플러시를 자동으로 호출하고 코드가 실행된다.

## 영속 -> 준영속
- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된(detached) 것을 준영속 상태라 한다.
- 준영속 상태에서는 영속성 컨텍스트가 제공하는 기능(dirty checking 등..)을 사용할 수 없다.

### 준영속 상태로 만드는 방법
- em.detach(entity) : 특정 엔티티만을 준영속 상태로 전환.
- em.clear() : 영속성 컨텍스트를 완전히 초기화.
- em.close() : 영속성 컨텍스트를 종료.

## 영속성 컨텍스트의 이점
- 1차 캐시 -같은 엔티티에 대해 find를 여러번 해도 쿼리문을 여러번 실행하지 않는다.
- 동일성 보장 - 1차 캐시에서 가져다 씀으로 참조 변수와 같이 동일성이 보장된다.(==)
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지(Dirty Checking) : 추가로 save해주지 않아도 인스턴스에 대한 참조 변수처럼 자연스럽게 데이터에 대한 update가 진행된다.
- 지연 로딩(Lazy Loading)

# 엔티티 매핑

![](Images/매핑%20어노테이션.png)

## 객체와 테이블 매핑
- Entity가 붙은 클래스는 JPA가 관리
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) 

## 데이터베이스 스키마 자동 생성
- 스키마란? 스키마는 데이터베이스 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
- hibernate.hbm2ddl.auto의 속성값을 통해 할 수 있다.
- create : 기존 테이블 삭제 후 다시 생성
- create-drop : create와 같으나 종료시점에 테이블 DROP
- update : 변경분만 반영(운영DB에서는 사용하면 안됨)
- validate : 엔티티와 테이블이 정상 매핑되었는지 확인
- none : 사용하지 않음
- 운영 장비에는 절대 create, create-drop, update 사용하면
안된다.


## 필드와 컬럼 매핑
![](Images/@Column.png)

### @Enumerated (오라클에서 체크 제약조건으로 사용자와 관리자를 구분했던 것의 기능을 한다.)
- 자바 enum 타입을 매핑할 때 사용
- ORDINAL사용 금지. (순번으로 나온다.)
- STRING으로 사용하여 이름을 데이터 베이스에 저장한다.

### @Temporal
- 날짜 타입을 매핑할 때 사용.
- LocalDate, LocalDateTime을 사용할 떄는 생략 가능(최신 하이버네이트 지원)
- TmeporalType.DATE : 날짜, 데이터베이스 date 타입과 매핑
- TemporalType.Time : 시간, 데이터베이스 time 타입과 매핑
- TemporalType.TIMESTAMP : 날짜와 시간, 데이터베이스 timestamp 타입과 매핑

### @Lob
- 데이터베이스 BLOB, CLOB 타입과 매핑
- @Lob에는 지정할 수 있는 속성이 없다.
- 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑

@Transient
- 필드 매핑X
- 데이터베이스에 저장X, 조회X
- 주로 메모리상에서 임시로 어떤 값을 보관하고 싶을 때 사용

## 기본 키 매핑
- 직접 할당 : @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY : 데이터베이스에 위임, MYSQL
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE
    - @SequenceGenerator 필요
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator필요
  - AUTO : 방언에 따라 자동 지정, 기본값

- @Id
- @GeneratedValue

# 연관관계 매핑 기초
## 단방향 연관관계
- 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다.
- 객체의 참조와 테이블의 외래 키를 매핑하는 것이 목표다.

### 방향(Direction) : [단방향, 양방향]
- 단방향 : 둘 중 한 쪽만 참조하는 것
- 양방향 : 양쪽이 모두 참조하는 것

### 다중성(Multiplicity) : [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)]

### 연관관계의 주인(owner) : 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다. 

## 양방향 연관관계 매핑 하는 법
- 대일 중 다에 해당하는(ex Member)부분에 테이블상의 FK에 해당하는 필드에 @ManyToOne이노테이션을 달아준다.
- @JoinColumn이노테이션을 달아주고 name 속성으로 컬럼명을 명시해 준다.
- 이와 연관관계를 가지는 그 반대편 엔티티(ex Team)의 필드에 @OneToMany어노테이션과 @mappedBy속성으로 주인 엔티티의 필드값을 입력해 준다.
- 여기서 주인은 Member엔티티의 team 필드가 된다.
- 연관관계의 주인은 외래 키가 있는 곳이 된다.
- 테이블상의 외래키 데이터에 접근할 수 있는 것은 연관관계의 주인뿐이다.
- 주인이 아닌 쪽은 읽기만 할 수 있다.
- 이러한 복잡성은 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하기 때문이다.
- 반면에 엔티티는 참조를 사용하므로 양방향의 참조가 필요하다.

###  양방향 연관관계 매핑 시 주의
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- **연관관계 편의 메소드**를 생성하자
- 양방향 매핑시에 무한 루프를 조심하자
  - 예 : toString(), lombok, JSON 생서 라이브러리

### 양방향 매핑 정리
- **단방향 매핑만으로도 이미 연관관계 매핑은 완료**
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
- JPQL에서 역방향으로 탐색할 일이 많음
- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨.(**테이블에 영향을 주지 않음**)

### 연관관계의 주인을 정하는 기준
- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함.

# 다양한 연관관계 매핑
- 다대일 [N:1]
- 일대다 [1:N]
- 일대일 [1:1]
- 다대다 [N:M]

## 연관관계 매핑시 고려사항 3가지
- 다중성
- 단방향, 양방향
- 연관관계의 주인

# 고급 매핑
##  상속관계 매핑
- 관계형 데이터베이스는 상속 관계X
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

### 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
- 각각 테이블로 변환 -> 조인 전략
- 통합 테이블로 변환 -> 단일 테이블 전략
- 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

## Mapped Superclass(매핑 정보 상속)
- 반복되는 필드를 한 수퍼클래스에 묶어서  @MappedSuper클래스 어노테이션을 붙여준다.

# 프록시와 연관관계 관리
## 프록시란?
- em.find() vs em.getReference()
- em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

### 프록시 특징
- 프록시 객체는 실제 객체의 참조(target)을 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

![](Images/proxy.png)
![](Images/proxy2.png)

중요!
1. 프록시 객체는 처음 사용할 때 한 번만 초기화
2. 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능(target)
3. 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교 실패, 대신 instance of 사용)
4. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
5. 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때    , 프록시를 초기화하면 문제 발생

### 프록시 확인
- 프록시 인스턴스의 초기화 여부 확인
  - PersistenceUnitUtil.isLoaded(Object entity)

## 즉시 로딩과 지연 로딩
- Member랑 Team을 따로 사용한다. - 지연로딩(Lazy)
  - 프록시 객체를 이용하여 지연로딩을 한다.
- Member랑 Team을 자주 함께 사용한다. - 즉시로딩(EAGER)
  - DB에서 진짜 객체를 가져온다.
- 단,! 실무에서는 지연로딩만 사용하면 된다.
 
### 프록시와 즉시로딩 주의
- 가급적 지연 로딩만 사용
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
- @ManytoOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정

## 영속성 전이(CASCADE)와 고아 객체
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들고 싶을 때

### 영속성 전이 + 고아 객체, 생명주기
- CascadeType.All + orphanRemovel=true
- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음
- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용

